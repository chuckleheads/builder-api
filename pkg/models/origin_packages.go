// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// OriginPackage is an object representing the database table.
type OriginPackage struct {
	ID            int64             `boil:"id" json:"id" toml:"id" yaml:"id"`
	OwnerID       int64             `boil:"owner_id" json:"owner_id" toml:"owner_id" yaml:"owner_id"`
	Name          null.String       `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	Ident         null.String       `boil:"ident" json:"ident,omitempty" toml:"ident" yaml:"ident,omitempty"`
	IdentArray    types.StringArray `boil:"ident_array" json:"ident_array,omitempty" toml:"ident_array" yaml:"ident_array,omitempty"`
	Checksum      null.String       `boil:"checksum" json:"checksum,omitempty" toml:"checksum" yaml:"checksum,omitempty"`
	Manifest      null.String       `boil:"manifest" json:"manifest,omitempty" toml:"manifest" yaml:"manifest,omitempty"`
	Config        null.String       `boil:"config" json:"config,omitempty" toml:"config" yaml:"config,omitempty"`
	Target        null.String       `boil:"target" json:"target,omitempty" toml:"target" yaml:"target,omitempty"`
	Deps          types.StringArray `boil:"deps" json:"deps,omitempty" toml:"deps" yaml:"deps,omitempty"`
	Tdeps         types.StringArray `boil:"tdeps" json:"tdeps,omitempty" toml:"tdeps" yaml:"tdeps,omitempty"`
	Exposes       types.Int64Array  `boil:"exposes" json:"exposes,omitempty" toml:"exposes" yaml:"exposes,omitempty"`
	SchedulerSync null.Bool         `boil:"scheduler_sync" json:"scheduler_sync,omitempty" toml:"scheduler_sync" yaml:"scheduler_sync,omitempty"`
	CreatedAt     null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt     null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Visibility    string            `boil:"visibility" json:"visibility" toml:"visibility" yaml:"visibility"`
	IdentVector   null.String       `boil:"ident_vector" json:"ident_vector,omitempty" toml:"ident_vector" yaml:"ident_vector,omitempty"`
	Origin        null.String       `boil:"origin" json:"origin,omitempty" toml:"origin" yaml:"origin,omitempty"`

	R *originPackageR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L originPackageL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OriginPackageColumns = struct {
	ID            string
	OwnerID       string
	Name          string
	Ident         string
	IdentArray    string
	Checksum      string
	Manifest      string
	Config        string
	Target        string
	Deps          string
	Tdeps         string
	Exposes       string
	SchedulerSync string
	CreatedAt     string
	UpdatedAt     string
	Visibility    string
	IdentVector   string
	Origin        string
}{
	ID:            "id",
	OwnerID:       "owner_id",
	Name:          "name",
	Ident:         "ident",
	IdentArray:    "ident_array",
	Checksum:      "checksum",
	Manifest:      "manifest",
	Config:        "config",
	Target:        "target",
	Deps:          "deps",
	Tdeps:         "tdeps",
	Exposes:       "exposes",
	SchedulerSync: "scheduler_sync",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	Visibility:    "visibility",
	IdentVector:   "ident_vector",
	Origin:        "origin",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var OriginPackageWhere = struct {
	ID            whereHelperint64
	OwnerID       whereHelperint64
	Name          whereHelpernull_String
	Ident         whereHelpernull_String
	IdentArray    whereHelpertypes_StringArray
	Checksum      whereHelpernull_String
	Manifest      whereHelpernull_String
	Config        whereHelpernull_String
	Target        whereHelpernull_String
	Deps          whereHelpertypes_StringArray
	Tdeps         whereHelpertypes_StringArray
	Exposes       whereHelpertypes_Int64Array
	SchedulerSync whereHelpernull_Bool
	CreatedAt     whereHelpernull_Time
	UpdatedAt     whereHelpernull_Time
	Visibility    whereHelperstring
	IdentVector   whereHelpernull_String
	Origin        whereHelpernull_String
}{
	ID:            whereHelperint64{field: `id`},
	OwnerID:       whereHelperint64{field: `owner_id`},
	Name:          whereHelpernull_String{field: `name`},
	Ident:         whereHelpernull_String{field: `ident`},
	IdentArray:    whereHelpertypes_StringArray{field: `ident_array`},
	Checksum:      whereHelpernull_String{field: `checksum`},
	Manifest:      whereHelpernull_String{field: `manifest`},
	Config:        whereHelpernull_String{field: `config`},
	Target:        whereHelpernull_String{field: `target`},
	Deps:          whereHelpertypes_StringArray{field: `deps`},
	Tdeps:         whereHelpertypes_StringArray{field: `tdeps`},
	Exposes:       whereHelpertypes_Int64Array{field: `exposes`},
	SchedulerSync: whereHelpernull_Bool{field: `scheduler_sync`},
	CreatedAt:     whereHelpernull_Time{field: `created_at`},
	UpdatedAt:     whereHelpernull_Time{field: `updated_at`},
	Visibility:    whereHelperstring{field: `visibility`},
	IdentVector:   whereHelpernull_String{field: `ident_vector`},
	Origin:        whereHelpernull_String{field: `origin`},
}

// OriginPackageRels is where relationship names are stored.
var OriginPackageRels = struct {
	OriginName                   string
	PackageOriginChannelPackages string
}{
	OriginName:                   "OriginName",
	PackageOriginChannelPackages: "PackageOriginChannelPackages",
}

// originPackageR is where relationships are stored.
type originPackageR struct {
	OriginName                   *Origin
	PackageOriginChannelPackages OriginChannelPackageSlice
}

// NewStruct creates a new relationship struct
func (*originPackageR) NewStruct() *originPackageR {
	return &originPackageR{}
}

// originPackageL is where Load methods for each relationship are stored.
type originPackageL struct{}

var (
	originPackageColumns               = []string{"id", "owner_id", "name", "ident", "ident_array", "checksum", "manifest", "config", "target", "deps", "tdeps", "exposes", "scheduler_sync", "created_at", "updated_at", "visibility", "ident_vector", "origin"}
	originPackageColumnsWithoutDefault = []string{"owner_id", "name", "ident", "ident_array", "checksum", "manifest", "config", "target", "deps", "tdeps", "exposes", "ident_vector", "origin"}
	originPackageColumnsWithDefault    = []string{"id", "scheduler_sync", "created_at", "updated_at", "visibility"}
	originPackagePrimaryKeyColumns     = []string{"id"}
)

type (
	// OriginPackageSlice is an alias for a slice of pointers to OriginPackage.
	// This should generally be used opposed to []OriginPackage.
	OriginPackageSlice []*OriginPackage
	// OriginPackageHook is the signature for custom OriginPackage hook methods
	OriginPackageHook func(context.Context, boil.ContextExecutor, *OriginPackage) error

	originPackageQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	originPackageType                 = reflect.TypeOf(&OriginPackage{})
	originPackageMapping              = queries.MakeStructMapping(originPackageType)
	originPackagePrimaryKeyMapping, _ = queries.BindMapping(originPackageType, originPackageMapping, originPackagePrimaryKeyColumns)
	originPackageInsertCacheMut       sync.RWMutex
	originPackageInsertCache          = make(map[string]insertCache)
	originPackageUpdateCacheMut       sync.RWMutex
	originPackageUpdateCache          = make(map[string]updateCache)
	originPackageUpsertCacheMut       sync.RWMutex
	originPackageUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var originPackageBeforeInsertHooks []OriginPackageHook
var originPackageBeforeUpdateHooks []OriginPackageHook
var originPackageBeforeDeleteHooks []OriginPackageHook
var originPackageBeforeUpsertHooks []OriginPackageHook

var originPackageAfterInsertHooks []OriginPackageHook
var originPackageAfterSelectHooks []OriginPackageHook
var originPackageAfterUpdateHooks []OriginPackageHook
var originPackageAfterDeleteHooks []OriginPackageHook
var originPackageAfterUpsertHooks []OriginPackageHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *OriginPackage) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *OriginPackage) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *OriginPackage) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *OriginPackage) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *OriginPackage) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *OriginPackage) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *OriginPackage) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *OriginPackage) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *OriginPackage) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range originPackageAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOriginPackageHook registers your hook function for all future operations.
func AddOriginPackageHook(hookPoint boil.HookPoint, originPackageHook OriginPackageHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		originPackageBeforeInsertHooks = append(originPackageBeforeInsertHooks, originPackageHook)
	case boil.BeforeUpdateHook:
		originPackageBeforeUpdateHooks = append(originPackageBeforeUpdateHooks, originPackageHook)
	case boil.BeforeDeleteHook:
		originPackageBeforeDeleteHooks = append(originPackageBeforeDeleteHooks, originPackageHook)
	case boil.BeforeUpsertHook:
		originPackageBeforeUpsertHooks = append(originPackageBeforeUpsertHooks, originPackageHook)
	case boil.AfterInsertHook:
		originPackageAfterInsertHooks = append(originPackageAfterInsertHooks, originPackageHook)
	case boil.AfterSelectHook:
		originPackageAfterSelectHooks = append(originPackageAfterSelectHooks, originPackageHook)
	case boil.AfterUpdateHook:
		originPackageAfterUpdateHooks = append(originPackageAfterUpdateHooks, originPackageHook)
	case boil.AfterDeleteHook:
		originPackageAfterDeleteHooks = append(originPackageAfterDeleteHooks, originPackageHook)
	case boil.AfterUpsertHook:
		originPackageAfterUpsertHooks = append(originPackageAfterUpsertHooks, originPackageHook)
	}
}

// One returns a single originPackage record from the query.
func (q originPackageQuery) One(ctx context.Context, exec boil.ContextExecutor) (*OriginPackage, error) {
	o := &OriginPackage{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for origin_packages")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all OriginPackage records from the query.
func (q originPackageQuery) All(ctx context.Context, exec boil.ContextExecutor) (OriginPackageSlice, error) {
	var o []*OriginPackage

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to OriginPackage slice")
	}

	if len(originPackageAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all OriginPackage records in the query.
func (q originPackageQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count origin_packages rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q originPackageQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if origin_packages exists")
	}

	return count > 0, nil
}

// OriginName pointed to by the foreign key.
func (o *OriginPackage) OriginName(mods ...qm.QueryMod) originQuery {
	queryMods := []qm.QueryMod{
		qm.Where("name=?", o.Origin),
	}

	queryMods = append(queryMods, mods...)

	query := Origins(queryMods...)
	queries.SetFrom(query.Query, "\"origins\"")

	return query
}

// PackageOriginChannelPackages retrieves all the origin_channel_package's OriginChannelPackages with an executor via package_id column.
func (o *OriginPackage) PackageOriginChannelPackages(mods ...qm.QueryMod) originChannelPackageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"origin_channel_packages\".\"package_id\"=?", o.ID),
	)

	query := OriginChannelPackages(queryMods...)
	queries.SetFrom(query.Query, "\"origin_channel_packages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"origin_channel_packages\".*"})
	}

	return query
}

// LoadOriginName allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (originPackageL) LoadOriginName(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOriginPackage interface{}, mods queries.Applicator) error {
	var slice []*OriginPackage
	var object *OriginPackage

	if singular {
		object = maybeOriginPackage.(*OriginPackage)
	} else {
		slice = *maybeOriginPackage.(*[]*OriginPackage)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &originPackageR{}
		}
		if !queries.IsNil(object.Origin) {
			args = append(args, object.Origin)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &originPackageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Origin) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Origin) {
				args = append(args, obj.Origin)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`origins`), qm.WhereIn(`name in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Origin")
	}

	var resultSlice []*Origin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Origin")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for origins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for origins")
	}

	if len(originPackageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OriginName = foreign
		if foreign.R == nil {
			foreign.R = &originR{}
		}
		foreign.R.OriginOPA = append(foreign.R.OriginOPA, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Origin, foreign.Name) {
				local.R.OriginName = foreign
				if foreign.R == nil {
					foreign.R = &originR{}
				}
				foreign.R.OriginOPA = append(foreign.R.OriginOPA, local)
				break
			}
		}
	}

	return nil
}

// LoadPackageOriginChannelPackages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (originPackageL) LoadPackageOriginChannelPackages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOriginPackage interface{}, mods queries.Applicator) error {
	var slice []*OriginPackage
	var object *OriginPackage

	if singular {
		object = maybeOriginPackage.(*OriginPackage)
	} else {
		slice = *maybeOriginPackage.(*[]*OriginPackage)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &originPackageR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &originPackageR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`origin_channel_packages`), qm.WhereIn(`package_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load origin_channel_packages")
	}

	var resultSlice []*OriginChannelPackage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice origin_channel_packages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on origin_channel_packages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for origin_channel_packages")
	}

	if len(originChannelPackageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PackageOriginChannelPackages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &originChannelPackageR{}
			}
			foreign.R.Package = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PackageID {
				local.R.PackageOriginChannelPackages = append(local.R.PackageOriginChannelPackages, foreign)
				if foreign.R == nil {
					foreign.R = &originChannelPackageR{}
				}
				foreign.R.Package = local
				break
			}
		}
	}

	return nil
}

// SetOriginName of the originPackage to the related item.
// Sets o.R.OriginName to related.
// Adds o to related.R.OriginOPA.
func (o *OriginPackage) SetOriginName(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Origin) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"origin_packages\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"origin"}),
		strmangle.WhereClause("\"", "\"", 2, originPackagePrimaryKeyColumns),
	)
	values := []interface{}{related.Name, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Origin, related.Name)
	if o.R == nil {
		o.R = &originPackageR{
			OriginName: related,
		}
	} else {
		o.R.OriginName = related
	}

	if related.R == nil {
		related.R = &originR{
			OriginOPA: OriginPackageSlice{o},
		}
	} else {
		related.R.OriginOPA = append(related.R.OriginOPA, o)
	}

	return nil
}

// RemoveOriginName relationship.
// Sets o.R.OriginName to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OriginPackage) RemoveOriginName(ctx context.Context, exec boil.ContextExecutor, related *Origin) error {
	var err error

	queries.SetScanner(&o.Origin, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("origin")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.OriginName = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.OriginOPA {
		if queries.Equal(o.Origin, ri.Origin) {
			continue
		}

		ln := len(related.R.OriginOPA)
		if ln > 1 && i < ln-1 {
			related.R.OriginOPA[i] = related.R.OriginOPA[ln-1]
		}
		related.R.OriginOPA = related.R.OriginOPA[:ln-1]
		break
	}
	return nil
}

// AddPackageOriginChannelPackages adds the given related objects to the existing relationships
// of the origin_package, optionally inserting them as new records.
// Appends related to o.R.PackageOriginChannelPackages.
// Sets related.R.Package appropriately.
func (o *OriginPackage) AddPackageOriginChannelPackages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OriginChannelPackage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PackageID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"origin_channel_packages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"package_id"}),
				strmangle.WhereClause("\"", "\"", 2, originChannelPackagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ChannelID, rel.PackageID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PackageID = o.ID
		}
	}

	if o.R == nil {
		o.R = &originPackageR{
			PackageOriginChannelPackages: related,
		}
	} else {
		o.R.PackageOriginChannelPackages = append(o.R.PackageOriginChannelPackages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &originChannelPackageR{
				Package: o,
			}
		} else {
			rel.R.Package = o
		}
	}
	return nil
}

// OriginPackages retrieves all the records using an executor.
func OriginPackages(mods ...qm.QueryMod) originPackageQuery {
	mods = append(mods, qm.From("\"origin_packages\""))
	return originPackageQuery{NewQuery(mods...)}
}

// FindOriginPackage retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOriginPackage(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*OriginPackage, error) {
	originPackageObj := &OriginPackage{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"origin_packages\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, originPackageObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from origin_packages")
	}

	return originPackageObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OriginPackage) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no origin_packages provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(originPackageColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	originPackageInsertCacheMut.RLock()
	cache, cached := originPackageInsertCache[key]
	originPackageInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			originPackageColumns,
			originPackageColumnsWithDefault,
			originPackageColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(originPackageType, originPackageMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(originPackageType, originPackageMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"origin_packages\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"origin_packages\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into origin_packages")
	}

	if !cached {
		originPackageInsertCacheMut.Lock()
		originPackageInsertCache[key] = cache
		originPackageInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the OriginPackage.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OriginPackage) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	originPackageUpdateCacheMut.RLock()
	cache, cached := originPackageUpdateCache[key]
	originPackageUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			originPackageColumns,
			originPackagePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update origin_packages, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"origin_packages\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, originPackagePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(originPackageType, originPackageMapping, append(wl, originPackagePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update origin_packages row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for origin_packages")
	}

	if !cached {
		originPackageUpdateCacheMut.Lock()
		originPackageUpdateCache[key] = cache
		originPackageUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q originPackageQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for origin_packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for origin_packages")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OriginPackageSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), originPackagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"origin_packages\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, originPackagePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in originPackage slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all originPackage")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OriginPackage) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no origin_packages provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(originPackageColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	originPackageUpsertCacheMut.RLock()
	cache, cached := originPackageUpsertCache[key]
	originPackageUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			originPackageColumns,
			originPackageColumnsWithDefault,
			originPackageColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			originPackageColumns,
			originPackagePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert origin_packages, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(originPackagePrimaryKeyColumns))
			copy(conflict, originPackagePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"origin_packages\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(originPackageType, originPackageMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(originPackageType, originPackageMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert origin_packages")
	}

	if !cached {
		originPackageUpsertCacheMut.Lock()
		originPackageUpsertCache[key] = cache
		originPackageUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single OriginPackage record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OriginPackage) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OriginPackage provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), originPackagePrimaryKeyMapping)
	sql := "DELETE FROM \"origin_packages\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from origin_packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for origin_packages")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q originPackageQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no originPackageQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from origin_packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for origin_packages")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OriginPackageSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OriginPackage slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(originPackageBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), originPackagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"origin_packages\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, originPackagePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from originPackage slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for origin_packages")
	}

	if len(originPackageAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OriginPackage) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOriginPackage(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OriginPackageSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OriginPackageSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), originPackagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"origin_packages\".* FROM \"origin_packages\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, originPackagePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OriginPackageSlice")
	}

	*o = slice

	return nil
}

// OriginPackageExists checks if the OriginPackage row exists.
func OriginPackageExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"origin_packages\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if origin_packages exists")
	}

	return exists, nil
}
